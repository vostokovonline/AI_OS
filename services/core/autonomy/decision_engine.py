"""
DECISION ENGINE - Action Generation and Execution

Orchestrates the decision loop:
1. Process artifact state mutations
2. Evaluate policy rules
3. Generate system actions
4. Execute approved actions

This is the core of autonomous operation.
"""
from datetime import datetime
from typing import Dict, Any, Optional, List
from enum import Enum
from uuid import UUID, uuid4
from dataclasses import dataclass, field

from logging_config import get_logger

from autonomy.system_state import SystemStateManager, EntityType
from autonomy.state_mutation import StateMutation, apply_state_mutation
from autonomy.policy_engine import PolicyEngine, PolicyEvaluationResult, ActionType

logger = get_logger(__name__)


@dataclass
class DecisionAction:
    """
    An action generated by the decision engine.
    
    Actions are created based on policy evaluations.
    They must be approved before execution.
    """
    id: UUID
    action_type: ActionType
    action_payload: Dict[str, Any]
    source_entity_name: str
    source_rule_name: str
    reason: str
    approved: bool = False
    executed: bool = False
    result: Optional[Dict[str, Any]] = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": str(self.id),
            "action_type": self.action_type.value,
            "action_payload": self.action_payload,
            "source_entity_name": self.source_entity_name,
            "source_rule_name": self.source_rule_name,
            "reason": self.reason,
            "approved": self.approved,
            "executed": self.executed,
            "result": self.result,
            "created_at": self.created_at.isoformat()
        }


class DecisionEngine:
    """
    The core decision-making component.
    
    Responsibilities:
    - Process state mutations from artifacts
    - Evaluate policies
    - Generate actions
    - Execute approved actions
    
    Key principle:
    - Artifacts PROPOSE mutations
    - Policy engine EVALUATES rules
    - Decision engine EXECUTES actions
    - State manager UPDATES state
    
    This separation ensures controlled autonomous operation.
    """
    
    def __init__(self):
        self.state_manager = SystemStateManager()
        self.policy_engine = PolicyEngine()
    
    async def process_artifact_mutations(
        self,
        mutations: List[StateMutation],
        artifact_id: UUID
    ) -> List[DecisionAction]:
        """
        Process state mutations proposed by an artifact.
        
        This is the main entry point for autonomous operation.
        
        Pipeline:
        1. Apply each mutation to state
        2. Evaluate policies for affected entities
        3. Generate actions from triggered rules
        4. Return actions for approval/execution
        
        Args:
            mutations: List of state mutations from artifact
            artifact_id: ID of the source artifact
            
        Returns:
            List of actions generated by policy evaluations
        """
        actions = []
        
        for mutation in mutations:
            mutation.source_artifact_id = artifact_id
            
            # 1. Get current state (if exists)
            current_entity = await self.state_manager.get_entity(mutation.entity_name)
            current_value = current_entity.current_value if current_entity else None
            
            # 2. Calculate new value
            new_value = await apply_state_mutation(mutation, current_value)
            
            # 3. Determine entity type (default to metric)
            entity_type = EntityType.METRIC
            if current_entity:
                entity_type = current_entity.entity_type
            
            # 4. Update state
            updated_entity = await self.state_manager.update_entity(
                entity_name=mutation.entity_name,
                entity_type=entity_type,
                new_value=new_value,
                source_artifact_id=artifact_id,
                confidence=mutation.confidence
            )
            
            logger.info(
                "state_updated",
                entity_name=mutation.entity_name,
                new_value=new_value,
                source_artifact=str(artifact_id)
            )
            
            # 5. Evaluate policies
            evaluation_results = await self.policy_engine.evaluate(updated_entity)
            
            # 6. Generate actions from triggered rules
            for result in evaluation_results:
                if result.triggered:
                    action = DecisionAction(
                        id=uuid4(),
                        action_type=result.rule.action_type,
                        action_payload=result.rule.action_payload,
                        source_entity_name=result.entity.entity_name,
                        source_rule_name=result.rule.name,
                        reason=result.reason
                    )
                    actions.append(action)
                    
                    # Mark rule as triggered
                    await self.policy_engine.mark_triggered(result.rule.id)
        
        logger.info(
            "mutations_processed",
            mutations_count=len(mutations),
            actions_generated=len(actions)
        )
        
        return actions
    
    async def execute_action(
        self,
        action: DecisionAction
    ) -> Dict[str, Any]:
        """
        Execute an approved action.
        
        This is where autonomous actions become real.
        
        Supported actions:
        - CREATE_GOAL: Create a new goal
        - ALERT: Log an alert
        - DEACTIVATE_STRATEGY: Mark strategy as inactive
        - ACTIVATE_STRATEGY: Mark strategy as active
        
        Args:
            action: The action to execute
            
        Returns:
            Execution result
        """
        if not action.approved:
            return {"status": "error", "message": "Action not approved"}
        
        result = {"status": "pending", "action_type": action.action_type.value}
        
        try:
            if action.action_type == ActionType.CREATE_GOAL:
                # Create goal via goal_executor
                from goal_executor import GoalExecutor
                from infrastructure.uow import create_uow_provider
                
                executor = GoalExecutor()
                get_uow = create_uow_provider()
                
                payload = action.action_payload
                
                async with get_uow() as uow:
                    goal = await executor.create_goal_with_uow(
                        uow=uow,
                        title=payload.get("title", "Autonomous goal"),
                        description=payload.get("description", ""),
                        goal_type=payload.get("goal_type", "achievable"),
                        auto_classify=False,
                        is_atomic=payload.get("is_atomic", False),
                        depth_level=payload.get("depth_level", 0),
                        parent_id=None,
                        user_id=None
                    )
                
                result = {
                    "status": "success",
                    "goal_id": str(goal.id),
                    "goal_title": goal.title
                }
                
                logger.info(
                    "autonomous_goal_created",
                    goal_id=str(goal.id),
                    title=goal.title,
                    source_rule=action.source_rule_name
                )
            
            elif action.action_type == ActionType.ALERT:
                # Log alert
                severity = action.action_payload.get("severity", "info")
                message = action.action_payload.get("message", "")
                
                if severity == "warning":
                    logger.warning(
                        "autonomous_alert",
                        message=message,
                        source_entity=action.source_entity_name
                    )
                elif severity == "critical":
                    logger.error(
                        "autonomous_alert",
                        message=message,
                        source_entity=action.source_entity_name
                    )
                else:
                    logger.info(
                        "autonomous_alert",
                        message=message,
                        source_entity=action.source_entity_name
                    )
                
                result = {"status": "success", "alert_logged": True}
            
            elif action.action_type == ActionType.DEACTIVATE_STRATEGY:
                # Update strategy state
                strategy_name = action.action_payload.get("strategy_name")
                if strategy_name:
                    await self.state_manager.update_entity(
                        entity_name=strategy_name,
                        entity_type=EntityType.STRATEGY,
                        new_value={"status": "deactivated", "reason": action.reason},
                        confidence=1.0
                    )
                    result = {"status": "success", "strategy_deactivated": strategy_name}
            
            elif action.action_type == ActionType.ACTIVATE_STRATEGY:
                # Activate strategy
                strategy_name = action.action_payload.get("strategy_name")
                if strategy_name:
                    await self.state_manager.update_entity(
                        entity_name=strategy_name,
                        entity_type=EntityType.STRATEGY,
                        new_value={"status": "active"},
                        confidence=1.0
                    )
                    result = {"status": "success", "strategy_activated": strategy_name}
            
            else:
                result = {"status": "error", "message": f"Unknown action type: {action.action_type}"}
            
            action.executed = True
            action.result = result
            
        except Exception as e:
            result = {"status": "error", "message": str(e)}
            action.result = result
            logger.error("action_execution_failed", action_id=str(action.id), error=str(e))
        
        return result
    
    async def run_decision_loop(
        self,
        mutations: List[StateMutation],
        artifact_id: UUID,
        auto_approve: bool = False
    ) -> List[Dict[str, Any]]:
        """
        Full decision loop: process, approve, execute.
        
        Args:
            mutations: State mutations from artifact
            artifact_id: Source artifact ID
            auto_approve: If True, automatically approve all actions
            
        Returns:
            List of execution results
        """
        # 1. Process mutations and get actions
        actions = await self.process_artifact_mutations(mutations, artifact_id)
        
        results = []
        
        for action in actions:
            # 2. Approve if auto_approve
            if auto_approve:
                action.approved = True
            
            # 3. Execute if approved
            if action.approved:
                result = await self.execute_action(action)
                results.append({
                    "action": action.to_dict(),
                    "execution_result": result
                })
            else:
                results.append({
                    "action": action.to_dict(),
                    "execution_result": {"status": "pending_approval"}
                })
        
        return results


# Singleton instance
decision_engine = DecisionEngine()
